# 数据库期末复习提纲

## 第一章  DBS概述

### 1. 四个概念 P4-5

* 数据：描述事物的符号记录
* 数据库：长期储存在计算机内、**有组织的**、**可共享的**大量数据的**集合**。
* 数据库管理系统：位于用户和操作系统之间的一层数据管理**软件**。
* 数据库系统：有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统。

数据 $\subset$ 数据库 $\subset$ 数据库管理系统 $\subset$ 数据库系统

### 2. 三级模式 P29

* 物理模式（内模式）：数据**物理结构**和**存储方式**的描述，是数据在数据库内部的组织方式。
* 逻辑模式（模式）：数据库中全体数据的**逻辑结构**和**特征**的描述，是所有用户的公共视图。
* 子模式（外模式）：数据库用户（包括应用程序员和最终用户）能够看见和使用的**局部数据的逻辑结构**和**特征**的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。

### 3. 两种数据独立性

* 逻辑数据独立性：用户的应用程序与数据库的**逻辑结构**是相互独立的。
* 物理数据独立性：用户的应用程序与数据库中**数据的物理存储**是相互独立的。

### 4. 三级模式两级映像 P30

* 外模式/模式映像：对应同一个模式可以有任意多个外模式。

  定义了一个外模式与模式之间的对应关系，通常包含在各自模式的描述中。

  当模式改变时，由数据库管理员对各个外模式/模式的映像作相应改变，使**外模式保持不变**。应用程序是依据数据的外模式编写的，从而**应用程序不必修改，保证的数据与程序的逻辑独立性**。

* 模式/内模式映像：只有唯一一个模式/内模式映像。

  定义了数据全局逻辑结构与存储结构之间的对应关系。

  当数据库的存储结构改变时，由数据库管理员对模式/内模式映像做相应改变，使**模式保持不变，从而应用程序不必改变，保证了数据与程序的物理独立性**。

### 5. 数据库系统的组成 P31-33

* 硬件平台及数据库
  1. 大内存
  2. 大硬盘，大磁带（或光盘）做备份
  3. 系统有较高的通道能力
* 软件
  1. 数据库管理系统
  2. 支持数据库管理系统运行的操作系统
  3. 具有与数据库接口的高级语言及其编译系统
  4. 以数据库管理系统为核心的应用开发工具
  5. 为特定应用环境开发的数据库应用系统
* 人员
  1. 数据库管理员 DBA, SA（甲方爸爸）
  2. 系统分析员和数据库设计人员
  3. 应用程序员
  4. 用户

### 6. 概念数据模型（ER模型：P215）

* 主要概念：

  （1）实体：客观存在并可相互区别的事物

  （2）属性：实体所具有的某一特性

  （2.5）域：属性的取值范围

  （3）码：唯一标识实体的属性

  （4）实体型：实体名及其属性名集合来抽象和刻画同类实体

  （5）实体集：同一类型实体的集合

  （6）联系：不同实体集之间的联系

  （7）元或度：参与联系的实体集的个数称为联系的元

### 7. 数据模型

* 三要素：数据结构、数据操作、数据完整性

* 层次模型：树结构

  优点：数据结构简单清晰、查询效率高

  缺点：不支持多对多联系、数据操纵不方便、子女结点信息容易丢失

* 网状模型：有向图；首记录型、属记录型

  优点：联系种类丰富

  缺点：结构比较复杂、语言复杂

* 关系模型：二维表

  优点：概念单一$$\rightarrow$$数据结构简单、清晰，用户易懂易用；更高的数据独立性

  缺点：查询效率低、增加了开发管理数据库系统的难度





## 第二章  关系模型与关系代数

### 1. 关系的定义及性质（P40-41）

- 关系的定义：P40

- 关系的性质：P41
  1. 列是同质的
  2. 不同的列可出自同一个域，称其中每一列为一个属性，不同的属性要给予不同的属性名
  3. 列的顺序无所谓
  4. 任意两个元组的候选码不能取相同的值（任何两行不能相同）
  5. 行的顺序无所谓
  6. 分量必须取原子值，即每一个分量都必须是不可分的数据项


### 2. 关系模式与关系实例（P42）

- 关系模式：关系的描述称为**关系模式**，它可以形式化地表示为 $R(U,D,DOM,F)$ ，其中 R 为关系名，U 为组成该关系的属性名集合， D 为 U 中属性所来自的域，DOM 为属性向域的映像集合，F 为属性间数据的依赖关系集合。
- 关系实例：PPT P10-12

### 3. 理解三类关系完整性

* 实体完整性
  - 主键不能为空
  - 主键不能重复
* 参照完整性
  * 不允许参照一个空的外码

* 用户定义完整性
  * 用户针对具体应用环境定义的完整性约束条件

### 4. 关系的候选键、主键、外键

* 候选键：关系中某一属性组的值能**唯一地**标识**一个元组**，而其**子集不能**
* 主键：一个关系有多个候选码，选定其中一个作为主码
* 外键：关系R中的一个属性组，它不是R的键/码，但它与另一个关系S的键/码相对应

### 5. 用关系代数表达查询（P48-54）

* **关系代数的基本运算**  
* **掌握选择、投影、连接、差运算等** 
  1. 选择 P51
  2. 投影 P53
  3. 连接 P53
  4. 差 P49
* **除运算不考查**





## 第三章  SQL语言

### 1.区别DDL、DML所完成功能的差异 P76-77

* DDL：对数据库中的某些对象进行管理，例如**CREATE,ALTER,DROP**
* DML：对数据库中的数据进行一些简单操作，例如**INSERT,DELETE,UPDATE,SELECT**等

### 2. 掌握SQL的各种数据定义语句（表及完整性、视图）

* 表及完整性：P82-85
* 视图：P121-124

- 创建表及完整性约束：**P82-87**

  ```sql
  CREATE TABLE <表名> (<列名><数据类型> [列级完整性约束条件],
                      <列名><数据类型> [列级完整性约束条件],
                      ...
                      <列名><数据类型> [列级完整性约束条件]);
  ```

  not null表示非空约束

  修改表：

  ```sql
  ALTER TABLE <表名>
  [ADD [COLUMN] <新列名><数据类型> [完整性约束]]
  [ADD <表级完整性约束>]
  [DROP [COLUMN] <列名> [CASCADE|RESTRICT]]
  [DROP CONSTRAINT <完整性约束名> [RESTRICT|CASCADE]]
  [ALTER COLUMN <列名><数据类型>];
  ```

  RESTRICT 表示该列被其他对象引用，则拒绝删除该列

  CASCADE 表示自动删除引用了该列的其他对象

  删除表：

  ```sql
  DROP TABLE <表名> [RESTRICT|CASCADE];
  ```

  选择CASCADE，在删除基本表的同时，相关的依赖对象，例如视图，都将被**一起**删除。

  基本表定义一旦被删除，不仅表中的数据和此表的定义将被删除，而且此表上建立的**索引**、**触发器**等对象一般也都将被删除。

- 视图：**P121-129***

  视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而**不存放**视图对应的数据，这些数据仍存放在原来的基本表中。

  建立：

  ```sql
  CREATE VIEW <视图名> [(<列名> [,<列名>]...)]
  AS <子查询>
  [WITH CHECK OPTION];
  ```

  

### 3. SQL语言表达查询  P89-115

* 查询语句中各子句执行的逻辑顺序

  SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY **PPT P26**

* **ORDER BY**子句相关知识（多个属性、空值、升序降序等）**P96-97**

  用户可以用ORDER BY子句对查询结果按照一个或者多个属性列的升序(ASC)或降序(DESC)排列，默认值为升序。

  例子：

  (带函数的排序方法)

  ```sql
  SELECT SN, 2023-birthyear as age
  FROM S
  ORDER BY age desc;
  ```

  ```sql
  SELECT SN, 2023-birthyear
  FROM S
  ORDER BY 2 desc;
  ```

  若数据带有**空值**，排序时显示的次序由具体系统实现来决定。一般升序空值放最后，降序空值放最前。

  (多个属性)

  ```SQL
  SELECT DNAME, PNAME
  FROM PROF, DEPT
  WHERE PROF.D# = DEPT.D#
  ORDER BY DNAME ASC, PNAME DESC;
  ```

* 去重复 **PPT P98-100**

* 空值处理（**is null**，除此以外不满足任何匹配条件）

  * 除 is null 以外不满足任何匹配条件
  * null参与算术运算结果为null
  * null参与比较运算结果为false
  * null参与聚集运算除count(*)外其他聚集函数均忽略。

* 模糊查询（通配符的使用:**%**和**_**）**PPT P43-44, 书P94-95**

  * %：代表任意长度（长度可以为0）的字符串
  * _：代表任意单个字符

* 掌握查询的基本结构、分组聚集运算、分组的选择、不相关子查询（**IN**或**NOT IN**）等

  * 基本结构：**PPT P27**
  * 分组聚集运算：**PPT P48-55, 书P98-99**
  * 分组的选择：
  * 不相关子查询：**书P103-105**

* **带存在量词的相关子查询不考查**

### 4. SQL数据操纵语言 P115-119

* INSERT、UPDATE、DELETE

### 5. 理解视图的本质和特点 P121-129

- 本质：一个**虚表**。
- 特点：
  1. 视图的数据是从基本表中导出的，每次对视图查询都要重新计算
  2. 视图之上还可以再定义视图

* 命名的查询语句，虚拟关系；动态变化；行列子集视图（更新限制）

### 6. 视图的优点 P121-129 PPT P78

* **简化用户操作**
* 使用户能够以**多种角度看待同一数据**（个性化）
* 对重构数据库提供了一定程度的**逻辑独立性**
* **对机密数据提供安全保护**（限制用户数据访问范围）
* **适当**利用试图可以更清晰地表达查询





## 第四章  关系数据模式设计

### 1. 关系模式设计中插入异常、删除异常、修改异常的具体含义、例子

**学校教务数据库为例**

* 插入异常：如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库
* 删除异常：如果某个系的学生全部毕业了，则在删除该系学生信息的同时，这个系及其系主任的信息也丢掉了
* 修改异常：面对数据冗余，当数据库修改数据时，需要付出很大的代价来维护数据库的完整性

### 2. 函数依赖（平凡的、完全的）

* 非平凡：$$X\rightarrow Y, 但Y\nsubseteq X$$
* 平凡：$$X\rightarrow Y,但Y\subseteq X$$
* 完全：$$X\xrightarrow{F}Y,并且对于X的任何一个真子集X^{'},都有X^{'}\nrightarrow Y$$
* 部分：$$X\xrightarrow{P}Y,但Y不完全依赖于X$$
* 传递：$$X\xrightarrow{传递}Z,其中X\rightarrow Y(Y\nsubseteq X),Y\nrightarrow X,Y\rightarrow Z, Z\subseteq Y$$

### 3. 属性集闭包的计算、会利用来求关系模式的候选键（P190-191）

* 逻辑蕴涵：对于关系模式R，F是其函数依赖，X,Y是其属性子集，如果从F的函数依赖能够推出X$$\rightarrow$$Y，则称F**逻辑蕴涵**X$$\rightarrow$$Y
* 闭包：被F所逻辑蕴涵的函数依赖的全体所构成的集合称作F的闭包，记作$$F^+=\{X\rightarrow Y|F\vdash X\rightarrow Y\}$$

### 4. 理解与掌握1NF、2NF、3NF、BCNF，并能够进行判定。（若干结论：单属性主键、全是主属性、无非平凡函数依赖或全码的模式等）

**对于关系模式R<U,F>：**

* 1NF：最低要求的关系：属性不可再分。
* 2NF：每一个**非主属性完全函数依赖**于**任何一个**候选码
* 3NF：R中**不存在**这样的码X，属性组Y及非主属性Z（$$Z\subseteq Y$$）使得$$X\rightarrow Y,Y\rightarrow Z$$成立，$$Y\nrightarrow X$$
* BCNF：$$X\rightarrow Y$$且$$Y\nsubseteq X$$时，X必含有码
* 关键结论：
  * **候选码为单属性，至少为2NF**
  * **全为主属性的关系模式，至少为3NF**
  * **任何一个二目关系模式，必为BCNF**
  * **全码关系范式，必为BCNF**

- 1NF → 2NF ：消除非主属性对码的**部分函数**依赖
- 2NF → 3NF ：消除非主属性对码的**传递函数**依赖
- 3NF → BCNF ：消除**主属性**对码的**部分**和**传递函数**依赖

### 5. 判断分解的无损连接性和保持函数依赖（包括判定算法和定理）

* 判断无损连接性：PPT 70-76
* 判断保持函数依赖：设ρ = {R1, R2, …, Rn}是关系模式R<U , F>的一个分解，如果$$F^{+}=(\bigcup\limits^{n}_{i=1}\Pi_{R_i}(F))$$ ，则称ρ是保持函数依赖的分解

### 6. 规范化到3NF，BCNF的相关方法

* 3NF：

  1. 求F的正则覆盖$$F_C$$ 

  2. 找出不在$$F_C$$中出现的属性，将它们构成一个关系模式$R_0<U_0,F_0>$，并从U中去掉它们(剩余属性仍记为U)

  3. 若有$$X\rightarrow A\in F_C$$ ，且XA=U，则ρ={R}，算法终止
  4. 对$$F_C$$按具有相同左部的原则进行分组（设为k 组），每一组函数依赖所涉及的属性全体为Ui， 令Fi为$$F_c$$在Ui上的投影，则 ρ = {R1<U1 , F1> , … ,  Rk<Uk , Fk>}是R<U , F>的一个保持函数依赖的分解，并且每个Ri<Ui , Fi> $$\in$$3NF

* BCNF：

  给定关系模式R<U , F> ，

  1. 令r = {R<U , F>}

  2. 检查r中各关系模式是否属于BCNF，若是，则算法终止。 

  3. 设r 中Ri<Ui , Fi>不属于BCNF，

     则存在函数依赖$$X\rightarrow A\in F^{+}_i$$，且X不是Ri的码，

     则XA是Ri的真子集，将Ri分解为$$\sigma=\{S1,S2\}$$，

     其中$$U_{S1} = XA， U_{S2} = U_i - \{A\}$$

     以s代替Ri ，返回到2



### 应用题型：给出关系和函数依赖

* 给出函数依赖（如果是具体例子）

* 求候选码

* 判断关系所属的最高范式，并给出证明。

* 将关系规范化到**3NF**，或者**BCNF**

* 判断或证明无损连接性





## 第五章  数据库设计

### 1. 数据库设计的各个阶段，每个阶段分别要做的主要工作

1. 需求分析（DFD(数据流程图), DD(数据字典)） **P211-214**

   1. 详细调查现实世界要处理的对象（组织、部门、企业等）
   2. 了解原系统（手工系统或计算机系统）的工作概况
   3. 明确用户的各种需求
   4. 在此基础上确定新系统的功能

   调查重点是**数据**和**处理**

2. 概念结构设计（E-R图） **P215-231**

   是整个数据库设计的**关键**对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型。

3. 逻辑结构设计（规范化）

   将概念结构转换为某个数据库管理系统所支持的数据模型，并对其进行优化。

4. 物理结构设计

   为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。

5. 数据库实施

6. 数据库运行和维护

### 2. ER图

* **ER**图的各个组成部分

  * 实体型，属性和联系

* 根据给定要求画**ER**图（**EER**模型不考查）**P218-219**

  * 关注**图7.11c**

* 将**ER**图转化为关系模式 **P231-232**

  一般原则：一个实体型转换为一个关系模式，关系的属性就是实体的属性，关系的码就是实体的码。

  实体型间的联系有以下5种情况：

  1. 1:1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并
  2. 1:n 联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并
  3. m:n 联系转换为一个关系模式
  4. 三个或三个以上实体间的一个多元联系可以转换为一个关系模式
  5. 具有相同码的关系模式可合并

  无论如何，优先保证**[部分参与]**加入**[全部参与]**

* **ER**图中的联系与关系模式外键的关系

- 能根据**ER**图分析出关系模式的主键、外键





## 第六章  安全性与完整性 P133-174

### 1. 安全性与完整性差别

* **安全性**：为防止非法用户的非法访问

  对象：非法用户、非法操作

* **完整性**：为防止合法用户的错误操作，从而防止错误数据进入数据库

  对象：不合语义的、不正确的数据

### 2. 实现数据库安全性的措施

* **用户身份鉴定**：最外层
* **自主存取控制**：用户权限授权
* **强制存取控制**：对数据本身进行密级标记
* **视图**：间接实现支持存取谓词的用户权限定义
* **审计**：把用户对数据库的所有操作自动记录下来放入审计日志。审计员可以利用审计日志监控数据库中的各种行为，重视导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。
* **数据加密存取**：
  * 存储加密
  * 传输加密

### 3. 角色的定义及作用

* 角色是被命名的一组与数据库操作相关的权限。角色是批量用户授权操作的需要，简化了授权的过程

### 4. 关系模型中的三类完整性规则，各有什么要求

* 实体完整性
  - 主键不能为空
  - 主键不能重复
* 参照完整性
  * 不允许参照一个空的外码
* 用户定义完整性
  * 用户针对具体应用环境定义的完整性约束条件

### 5. 针对基本关系或依赖关系，哪些操作会破坏完整性；各种操作破坏这些完整性规则的处理方法（拒绝、级联、置空）P158-165



### 6. 触发器的定义及主要作用（详细语法结构不考查）

* 触发器是在有触发事件后，满足一定的触发条件而执行一组动作的一个特殊的存储过程。它主要用来实现完整性，也可以实现一些自动操作。



## 第七章  数据库事务管理

**数据库运行的基本单位：事务**

### 1. 事务

* 定义：是用户定义的一个数据库操作**序列**

* 事务的**ACID**性质（包括确切含义、保障机制）
  * 确切含义：A: 原子性，C: 一致性，I: 隔离性，D: 持续性
  * 保障机制：A: 恢复机制，I: 并发控制，D: 恢复机制


### 2. 数据库故障恢复的实现技术（数据转储、登记日志文件）

* 数据转储：数据库管理员定期将数据库复制得到后备副本保存起来
  * **静态转储**：系统中无运行事务时进行
  * **动态转储**：允许在转储期间对数据库进行存取或修改
  * 还可分为**海量转储**和**增量转储**

* 日志文件：用于记录事务对数据库的更新操作的文件
  * 两种格式：以**记录**为单位的日志文件和以**数据块**为单位的日志文件。
    * 以记录为单位的日志文件中要登记的内容包括事务的开始与结束标记以及各个事务的所有更新操作
    * 以数据块为单位的日志文件，其日志记录的内容包括事务标识和更新的数据块

### 3. 登记日志的原则

* 登记次序严格按并发事务执行的时间次序

* 必须先写日志文件，后写数据库

### 4. 日志文件记录的内容

* 事务标识
* 操作的类型
* 操作对象
* 更新前数据的旧值
* 更新后数据的新值

### 5. 数据库中几种类型的故障；故障的起因（死锁属于事务故障）、恢复策略、恢复过程由谁完成（用户干预？）

* 分类

  * 事务内部的故障

    * 可预期的（余额不足）

    * 非预期的（运算溢出、并发事务死锁、违反了某些完整性限制等）

    * 通过事务撤消（UNDO）恢复

  * 系统故障（软故障）

    * 死机、CPU故障、OS故障、突然停电等导致系统需要重新启动。

    * UNDO未完成事务、REDO已提交事务

  * 介质故障（硬故障）

    * 磁盘损坏等外存故障

  * 计算机病毒

* 恢复策略

  * 事务故障

    * 事务故障恢复是由系统自动完成的，对用户是透明的。

    * 系统恢复步骤：
      1、反向扫描文件日志，找到该事务的更新操作

      2、对该事务的更新操作进行逆操作

      3、反向扫描日志文件，逐条找到其他更新操作，并同样进行逆操作，直到读到该事务的开始标记，事务故障恢复即告完成

  * 系统故障

    * 系统故障造成数据库不一致状态的原因
      * 未完成事务对数据库的更新已写入数据库
      * 已提交事务对数据库的更新还留在缓冲区没来得及写入数据库

    * 恢复方法
      * Undo 故障发生时未完成的事务
      * Redo 已完成的事务

    * 系统故障的恢复
      * 系统故障的恢复是由系统在重新启动时自动完成的，不需要用户的干预

  * 介质故障

    * 介质故障的恢复
      * 介质故障的恢复一般由DBA来完成。

    * 恢复的步骤：

      * 装入最新的数据库后备副本，使数据库恢复到最近一次转储时的一致性状态。（对于动态转储的数据库副本，还需同时装入转储开始时刻的日志文件副本，通过REDO+UNDO操作恢复到一致性状态。）

      * 装入相应的日志文件副本(转储结束时刻的日志文件副本)，重做已完成的事务。

### 6. 检查点的主要作用

* 改善恢复效率

### 7. 系统故障带有检查点的恢复策略

* 在重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录

* 由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST，把ACTIVE-LIST暂时放入UNDO-LIST，REDO-LIST暂为空

* 从检查点开始正向扫描日志文件。如有新开始的事物Ti，把Ti暂时放入UNDO-LIST；如有提交的事务Tj，把Tj从UNDO-LIST移到REDO-LIST，直到日志文件结束

* 对UNDO-LIST中的每个事务执行UNDO操作，对REDO-LIST中的每个事务执行REDO操作

### 8. 并发操作产生的三类数据不一致性问题，它们是如何发生的

* 丢失修改
  * 两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改丢失
* 不可重复读
  * 事务T1读取某一数据后，事务T2对其做了修改，当T1再次读取该数据时，得到与前次不同的值
* 读脏数据
  * 事务T2修改某一数据，并将其写回磁盘，事务T1读取同一数据后，T2由于某种原因被撤消，这时T2已修改过的数据恢复原值，T1读到的数据与数据库中数据不一致，则T1读到的数据就是脏数据

### 9. 三级封锁协议具体内容及分别解决哪些不一致性问题

* 内容
  * 一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束（commit或rollback）才释放。可防止**丢失修改**，并保证事务T是**可恢复**的
  * 二级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。还可以防止**读“脏"数据**
  * 三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。还可以防止**不可重复读**

### 10. 并发调度的正确性准则及判断方法

* 多个事务的并发执行是正确的

  $$\Leftrightarrow$$其结果与按某一次序串行地执行它们时的结果相同，这种调度策略称为可串行化的调度

* 可串行化调度的充分条件：冲突可串行化调度

  * 冲突可串行化判定

    * 优先图(precedence graph)

      一个调度S的优先图是这样构造的：它是一个有向图G =（V，E），V是顶点集，E是边集。顶点集由所有参与调度的事务组成，边集由满足下述条件之一的边Ti® Tj组成：

      ①在Tj执行read(Q)之前，Ti执行write(Q

      ②在Tj执行write(Q)之前，Ti执行read(Q)

      ③在Tj执行write(Q)之前，Ti执行write(Q)

      如果优先图中存在边Ti®Tj ，则在任何等价于S的串行调度S'中，Ti都必须出现在Tj之前

      * 冲突可串行化判定准则

        如果调度S的优先图中有环，则调度S是非冲突可串行化的。如果图中无环，则调度S是冲突可串行化的

      * 与冲突可串行化等价的串行顺序

        串行顺序可由拓扑排序得到，求出与优先图的偏序相一致的线序

### 11. 死锁的概念及解决方法

* 概念

  * 如果有两个或两个以上事务同时要对两个或两个以上不同的数据加锁就可能发生相互等待的问题，从而形成死锁

* 解决方法

  * 预防

    * 一次封锁法
      * 要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行
      * 存在的问题：降低系统并发度、难于事先精确确定封锁对象

    * 顺序封锁法
      * 预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。
      * 顺序封锁法存在的问题
        * 维护成本：数据库系统中封锁的数据对象极多，并且在不断地变化
        * 难以实现：很难事先确定每一个事务要封锁哪些对象

  * 检测与恢复

    * 基本观点：允许发生死锁，再检测，然后选择代价最小的事务回滚

    * 超时法

      * 判断事务的等待时间超过规定的时限，认为有死锁

      * 优点：实现简单

      * 缺点：时限不太好设置，时限太短可能误判死锁，时限太长，死锁发生又不能及时发现

    * 等待图法

      * 用事务等待图动态反映所有事务的等待情况
      * 事务等待图是一个有向图G=(T，U)
        * T为结点的集合，每个结点表示正运行的事务
        * U为边的集合，每条边表示事务等待的情况
        * 若T1等待T2，则T1，T2之间划一条有向边，从T1指向T2

  * 解除

    * 选择一个处理死锁代价最小的事务，将其撤消

    * 释放此事务持有的所有的锁，使其它事务能继续运行下去

### 12. 两段锁协议的内容

* 内容：

  ①在对任何数据进行读写之前，事务首先要获得对该数据的封锁。

  ②在释放一个封锁之后，事务不再获得任何其它封锁。

  * 即事务分为两个阶段：
    * 生长阶段：获得封锁
    * 收缩阶段：释放封锁

* 定理：如果所有事务都遵守两段锁协议，调度一定是可串行化的

* 两段锁协议不能防止死锁的发生





## 题型

|   选择   |   15×2   |   30分   |
| :------: | :------: | :------: |
| **判断** | **5×2**  | **10分** |
| **简答** | **4×5**  | **20分** |
| **分析** | **2×10** | **20分** |
| **综合** | **5×4**  | **20分** |

